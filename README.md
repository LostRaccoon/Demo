# 骑士巡游问题求解器 (Knight's Tour Solver)

这是一个用Python实现的骑士巡游问题求解器，可以在给定的棋盘上找到骑士的移动路径，并生成可视化图片。

## 功能特性

- **多种算法**: 支持Warnsdorff启发式算法和回溯算法
- **灵活配置**: 可指定棋盘大小、起点和终点
- **图像生成**: 自动生成带有移动序号的路径图片
- **完整巡游**: 尝试访问棋盘上的所有格子
- **交互模式**: 提供简单易用的交互式界面

## 安装依赖

```bash
pip install numpy matplotlib
# 或者使用 requirements.txt
pip install -r requirements.txt
```

## 使用方法

### 1. 命令行模式

基本用法：
```bash
python3 knight_tour.py <棋盘大小> <起点X> <起点Y> [选项]
```

参数说明：
- `棋盘大小`: 棋盘的大小 (如 5 表示 5x5 棋盘)
- `起点X, 起点Y`: 起始位置坐标 (从0开始)
- `--end_x, --end_y`: 终点坐标 (可选)
- `--method`: 求解算法 (`warnsdorff` 或 `backtrack`)
- `--output`: 输出图片文件名

示例：
```bash
# 5x5棋盘，从(0,0)开始
python3 knight_tour.py 5 0 0

# 6x6棋盘，从(1,1)到(4,4)
python3 knight_tour.py 6 1 1 --end_x 4 --end_y 4

# 使用回溯算法
python3 knight_tour.py 4 0 0 --method backtrack
```

### 2. 交互式模式

```bash
python3 interactive_knight_tour.py
```

程序会引导您输入棋盘大小、起点、终点等参数。

### 3. 演示模式

```bash
python3 demo.py
```

运行预设的多个测试用例，展示不同配置下的求解效果。

## 算法说明

### Warnsdorff启发式算法
- **优点**: 速度快，适合大棋盘 (推荐)
- **原理**: 优先选择度数最小的位置（可访问邻居最少的位置）
- **适用**: 一般情况下的骑士巡游问题

### 回溯算法
- **优点**: 完整搜索，保证找到解（如果存在）
- **缺点**: 速度较慢，适合小棋盘 (≤6x6)
- **适用**: 需要保证找到解的情况

## 输出说明

程序会生成PNG格式的图片，显示：
- **棋盘格子**: 黑白相间的棋盘
- **移动序号**: 每个格子中的红色数字表示访问顺序
- **移动路径**: 蓝色线条连接移动路径
- **起点终点**: 绿色圆点表示起点，红色圆点表示终点

## 示例结果

程序已经生成了以下测试图片：
- `demo_case_1_5x5.png`: 5x5完整巡游
- `demo_case_2_6x6.png`: 6x6指定终点
- `demo_case_3_8x8.png`: 8x8完整巡游

## 技术细节

### 骑士移动规则
骑士按照国际象棋规则移动：L形移动，即水平或垂直移动2格，然后垂直或水平移动1格。

### 坐标系统
- 使用(x, y)坐标，其中x表示行，y表示列
- 坐标从(0, 0)开始，到(size-1, size-1)结束
- 图片中的坐标已经转换为标准的图形坐标系

### 性能考虑
- 4x4及以下: 两种算法都很快
- 5x5到8x8: 推荐使用Warnsdorff算法
- 8x8以上: 仅推荐Warnsdorff算法

## 常见问题

**Q: 为什么有时候找不到完整的巡游路径？**
A: 骑士巡游问题在某些起点/终点组合下可能无解，特别是在指定终点的情况下。可以尝试更换起点或终点位置。

**Q: 哪种算法更好？**
A: 对于一般使用，推荐Warnsdorff算法，因为它速度快且通常能找到很好的解。只有在需要保证找到解的情况下才使用回溯算法。

**Q: 支持的最大棋盘大小是多少？**
A: 理论上没有限制，但建议不超过20x20，因为更大的棋盘可能导致求解时间过长或内存不足。

## 文件说明

- `knight_tour.py`: 主程序，包含核心算法和命令行接口
- `interactive_knight_tour.py`: 交互式界面
- `demo.py`: 演示脚本
- `requirements.txt`: 依赖包列表
- `README.md`: 说明文档

## 许可证

本项目仅供学习和研究使用。